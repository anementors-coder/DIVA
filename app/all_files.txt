Folder PATH listing
Volume serial number is CA69-10D6
C:.
|   .env
|   .gitignore
|   create_onboarding_tables.py
|   directory_structure.txt
|   oauth-public.key
|   poetry
|   poetry.lock
|   pyproject.toml
|   README.md
|   secrets-to-remove.txt
|   
\---app
    |   alembic.ini
    |   main.py
    |   __init__.py
    |   
    +---alembic
    |   |   env.py
    |   |   README
    |   |   script.py.mako
    |   |   
    |   \---versions
    |           a7300fc42c26_initial_schema.py
    |           002_insert_onboarding_questions.py
    |           
    +---api
    |   |   api.py
    |   |   __init__.py
    |   |   
    |   \---endpoints
    |           auth.py
    |           onboarding.py
    |           __init__.py
    |           
    +---core
    |       config.py
    |       redis.py
    |       security.py
    |       __init__.py
    |       
    +---crud
    |       onboarding.py
    |       __init__.py
    |       
    +---db
    |       base.py
    |       session.py
    |       __init__.py
    |       
    +---models
    |       onboarding.py
    |       __init__.py
    |       
    +---schemas
    |       onboarding.py
    |       __init__.py
    |       
    \---utils
            exceptions.py
            redis_utils.py
            

these are my files 

>> schemas/onboarding.py 
from pydantic import BaseModel, HttpUrl
from typing import Optional, List

# -----------------------------
# Schema for OnboardQuest
# -----------------------------
class OnboardQuestRead(BaseModel):
    id: int
    question: str

    class Config:
        from_attributes = True


# -----------------------------
# Schemas for UserInfo
# -----------------------------
class UserInfoBase(BaseModel):
    q1: str
    q2: str
    q3: str
    q4: str
    q5: str
    q6: str
    q7: str
    resume_url: Optional[HttpUrl] = None
    linkedin_url: Optional[HttpUrl] = None


class UserInfoCreate(UserInfoBase):
    usid: int  # user id decoded from JWT


class UserInfoRead(UserInfoBase):
    usid: int

    class Config:
        from_attributes = True


class UserInfoUpdate(BaseModel):
    q1: Optional[str] = None
    q2: Optional[str] = None
    q3: Optional[str] = None
    q4: Optional[str] = None
    q5: Optional[str] = None
    q6: Optional[str] = None
    q7: Optional[str] = None
    resume_url: Optional[HttpUrl] = None
    linkedin_url: Optional[HttpUrl] = None
---
>> utils/redis_utils.py
"""
Redis utilities for handling JWT tokens and user data storage.
This module provides functions to store and retrieve user data that persists
beyond JWT token expiration.
"""

import json
import time
from typing import Dict, Optional, Any
from app.core.redis import redis_client


class RedisUserManager:
    """Manages user data in Redis with different TTL strategies"""
    
    # TTL Constants (in seconds)
    JWT_TTL_BUFFER = 60  # 1 minute buffer for JWT storage
    USER_DATA_TTL = 30 * 24 * 60 * 60  # 30 days
    SESSION_TTL = 7 * 24 * 60 * 60  # 7 days
    
    @staticmethod
    def store_jwt_payload(jti: str, payload: Dict[str, Any], ttl: int) -> bool:
        """
        Store JWT payload with JTI key (expires with token)
        
        Args:
            jti: JWT ID
            payload: JWT payload
            ttl: Time to live in seconds
            
        Returns:
            bool: Success status
        """
        try:
            redis_client.setex(f"jwt:{jti}", ttl, json.dumps(payload))
            return True
        except Exception as e:
            print(f"Error storing JWT payload: {e}")
            return False
    
    @staticmethod
    def get_jwt_payload(jti: str) -> Optional[Dict[str, Any]]:
        """
        Get JWT payload by JTI (only works if token hasn't expired)
        
        Args:
            jti: JWT ID
            
        Returns:
            Dict containing JWT payload or None
        """
        try:
            data = redis_client.get(f"jwt:{jti}")
            if not data:
                return None
            return json.loads(data)
        except (json.JSONDecodeError, Exception) as e:
            print(f"Error retrieving JWT payload: {e}")
            return None
    
    @staticmethod
    def store_user_data(user_id: str, payload: Dict[str, Any]) -> bool:
        """
        Store essential user data with extended TTL (persists beyond JWT expiration)
        
        Args:
            user_id: User identifier
            payload: JWT payload or user data
            
        Returns:
            bool: Success status
        """
        try:
            user_data = {
                "user_id": user_id,
                "jti": payload.get("jti"),
                "aud": payload.get("aud"),
                "scopes": payload.get("scopes", []),
                "stored_at": int(time.time()),
                "exp": payload.get("exp")
            }
            
            # Store user data with extended TTL
            redis_client.setex(
                f"user:{user_id}:data", 
                RedisUserManager.USER_DATA_TTL, 
                json.dumps(user_data)
            )
            
            # Store latest JTI mapping
            redis_client.setex(
                f"user:{user_id}:latest_jti", 
                RedisUserManager.USER_DATA_TTL, 
                payload.get("jti", "")
            )
            
            return True
        except Exception as e:
            print(f"Error storing user data: {e}")
            return False
    
    @staticmethod
    def get_user_data(user_id: str) -> Optional[Dict[str, Any]]:
        """
        Get user data by user_id (works even after JWT expiration)
        
        Args:
            user_id: User identifier
            
        Returns:
            Dict containing user data or None
        """
        try:
            data = redis_client.get(f"user:{user_id}:data")
            if not data:
                return None
            return json.loads(data)
        except (json.JSONDecodeError, Exception) as e:
            print(f"Error retrieving user data: {e}")
            return None
    
    @staticmethod
    def get_user_latest_jti(user_id: str) -> Optional[str]:
        """
        Get the latest JTI for a user
        
        Args:
            user_id: User identifier
            
        Returns:
            str: Latest JTI or None
        """
        try:
            return redis_client.get(f"user:{user_id}:latest_jti")
        except Exception as e:
            print(f"Error retrieving latest JTI: {e}")
            return None
    
    @staticmethod
    def store_session_data(user_id: str, data: Dict[str, Any]) -> bool:
        """
        Store additional session data for user
        
        Args:
            user_id: User identifier
            data: Session data to store
            
        Returns:
            bool: Success status
        """
        try:
            session_data = {
                **data,
                "updated_at": int(time.time())
            }
            redis_client.setex(
                f"user:{user_id}:session", 
                RedisUserManager.SESSION_TTL, 
                json.dumps(session_data)
            )
            return True
        except Exception as e:
            print(f"Error storing session data: {e}")
            return False
    
    @staticmethod
    def get_session_data(user_id: str) -> Optional[Dict[str, Any]]:
        """
        Get session data for user
        
        Args:
            user_id: User identifier
            
        Returns:
            Dict containing session data or None
        """
        try:
            data = redis_client.get(f"user:{user_id}:session")
            if not data:
                return None
            return json.loads(data)
        except (json.JSONDecodeError, Exception) as e:
            print(f"Error retrieving session data: {e}")
            return None
    
    @staticmethod
    def delete_user_data(user_id: str) -> bool:
        """
        Delete all user data from Redis
        
        Args:
            user_id: User identifier
            
        Returns:
            bool: Success status
        """
        try:
            keys_to_delete = [
                f"user:{user_id}:data",
                f"user:{user_id}:latest_jti",
                f"user:{user_id}:session"
            ]
            
            # Also delete JWT if we have the JTI
            jti = RedisUserManager.get_user_latest_jti(user_id)
            if jti:
                keys_to_delete.append(f"jwt:{jti}")
            
            deleted_count = redis_client.delete(*keys_to_delete)
            return deleted_count > 0
        except Exception as e:
            print(f"Error deleting user data: {e}")
            return False
    
    @staticmethod
    def is_user_data_valid(user_id: str) -> bool:
        """
        Check if user has valid data in Redis
        
        Args:
            user_id: User identifier
            
        Returns:
            bool: True if user data exists and is valid
        """
        try:
            user_data = RedisUserManager.get_user_data(user_id)
            if not user_data:
                return False
            
            # Check if data is not too old (optional validation)
            stored_at = user_data.get("stored_at", 0)
            current_time = int(time.time())
            max_age = RedisUserManager.USER_DATA_TTL
            
            return (current_time - stored_at) < max_age
        except Exception as e:
            print(f"Error validating user data: {e}")
            return False


# Create instance for easy import
redis_user_manager = RedisUserManager()
---
>> db/base.py
from app.db.base_class import Base
---
>> db/session.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.core.config import settings

# Create the SQLAlchemy engine
engine = create_engine(settings.DATABASE_URL, pool_pre_ping=True)

# Create a session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

---
>> models/onboarding.py
from sqlalchemy import Column, Integer, String

from app.db.base import Base
target_metadata = Base.metadata

# -----------------------------
# Table 1: OnboardQuest
# -----------------------------
class OnboardQuest(Base):
    __tablename__ = "onboard_quest"

    id = Column(Integer, primary_key=True, index=True)
    question = Column(String, nullable=False, unique=True)


# -----------------------------
# Table 2: UserInfo
# -----------------------------
class UserInfo(Base):
    __tablename__ = "user_info"

    usid = Column(Integer, primary_key=True, index=True)
    q1 = Column(String, nullable=False)
    q2 = Column(String, nullable=False)
    q3 = Column(String, nullable=False)
    q4 = Column(String, nullable=False)
    q5 = Column(String, nullable=False)
    q6 = Column(String, nullable=False)
    q7 = Column(String, nullable=False)
    resume_url = Column(String, nullable=True)
    linkedin_url = Column(String, nullable=True)

---
>> crud/onboarding.py
from sqlalchemy.orm import Session
from typing import List, Optional

from app.models.onboarding import OnboardQuest, UserInfo
from app.schemas.onboarding import UserInfoCreate, UserInfoUpdate


class OnboardQuestCRUD:
    def get_all_questions(self, db: Session) -> List[OnboardQuest]:
        """Get all onboarding questions"""
        return db.query(OnboardQuest).order_by(OnboardQuest.id).all()
    
    def get_question_by_id(self, db: Session, question_id: int) -> Optional[OnboardQuest]:
        """Get a specific question by ID"""
        return db.query(OnboardQuest).filter(OnboardQuest.id == question_id).first()


class UserInfoCRUD:
    def create_user_info(self, db: Session, user_info: UserInfoCreate) -> UserInfo:
        """Create new user info record"""
        db_user_info = UserInfo(**user_info.dict())
        db.add(db_user_info)
        db.commit()
        db.refresh(db_user_info)
        return db_user_info
    
    def get_user_info(self, db: Session, usid: int) -> Optional[UserInfo]:
        """Get user info by user ID"""
        return db.query(UserInfo).filter(UserInfo.usid == usid).first()
    
    def update_user_info(self, db: Session, usid: int, user_info: UserInfoUpdate) -> Optional[UserInfo]:
        """Update user info"""
        db_user_info = db.query(UserInfo).filter(UserInfo.usid == usid).first()
        if db_user_info:
            update_data = user_info.dict(exclude_unset=True)
            for field, value in update_data.items():
                setattr(db_user_info, field, value)
            db.commit()
            db.refresh(db_user_info)
        return db_user_info
    
    def delete_user_info(self, db: Session, usid: int) -> bool:
        """Delete user info"""
        db_user_info = db.query(UserInfo).filter(UserInfo.usid == usid).first()
        if db_user_info:
            db.delete(db_user_info)
            db.commit()
            return True
        return False


# Create instances
onboard_quest_crud = OnboardQuestCRUD()
user_info_crud = UserInfoCRUD() 

---

>> api/api.py
# backend\app\app\api\v1\api.py
from fastapi import APIRouter
from app.api.endpoints import onboarding, auth

api_router = APIRouter()

api_router.include_router(onboarding.router, prefix="/signup", tags=["Onboarding"])
api_router.include_router(auth.router, prefix="/auth", tags=["Auth"])
---
>> api/endpoints/auth.py
from fastapi import APIRouter, Depends, HTTPException
from fastapi.security import HTTPBearer
from app.core.security import verify_passport_jwt
from app.core.redis import get_jwt_from_redis, get_user_data_by_id, get_latest_jti_for_user

router = APIRouter()
auth = HTTPBearer()

@router.get("/secure")
def secure_route(claims: dict = Depends(verify_passport_jwt)):
    """
    Protected route that returns JWT claims.
    """
    return {
        "ok": True,
        "user_id": claims.get("sub"),
        "aud": claims.get("aud"),
        "scopes": claims.get("scopes", []),
        "exp": claims.get("exp"),
        "jti": claims.get("jti"),
    }

@router.get("/redis/{jti}")
def get_token_from_redis(jti: str):
    """
    Retrieve stored JWT payload from Redis by JTI.
    """
    payload = get_jwt_from_redis(jti)
    if not payload:
        raise HTTPException(status_code=404, detail="Token not found in Redis")
    return {"jti": jti, "payload": payload}

@router.get("/user/{user_id}/data")
def get_user_data(user_id: str):
    """
    Retrieve user data from Redis by user_id.
    This works even after JWT expiration.
    """
    user_data = get_user_data_by_id(user_id)
    if not user_data:
        raise HTTPException(status_code=404, detail="User data not found in Redis")
    return {"user_id": user_id, "data": user_data}

@router.get("/user/{user_id}/latest-jti")
def get_user_latest_jti(user_id: str):
    """
    Get the latest JTI for a user.
    Useful for retrieving user data after token expiration.
    """
    jti = get_latest_jti_for_user(user_id)
    if not jti:
        raise HTTPException(status_code=404, detail="No JTI found for user")
    return {"user_id": user_id, "latest_jti": jti}
---
>> api/endpoints/onboarding.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from app.db.session import SessionLocal
from app.schemas.onboarding import OnboardQuestRead, UserInfoCreate, UserInfoRead, UserInfoUpdate
from app.crud.onboarding import onboard_quest_crud, user_info_crud
from app.core.security import verify_passport_jwt

router = APIRouter()

# Dependency to get DB session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


@router.get("/questions", response_model=List[OnboardQuestRead])
def get_onboarding_questions(db: Session = Depends(get_db)):
    """
    Get all onboarding questions.
    """
    questions = onboard_quest_crud.get_all_questions(db)
    return questions


@router.get("/questions/{question_id}", response_model=OnboardQuestRead)
def get_onboarding_question(question_id: int, db: Session = Depends(get_db)):
    """
    Get a specific onboarding question by ID.
    """
    question = onboard_quest_crud.get_question_by_id(db, question_id)
    if not question:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, 
            detail="Question not found"
        )
    return question


@router.post("/user-info", response_model=UserInfoRead)
def create_user_info(
    user_info: UserInfoCreate,
    db: Session = Depends(get_db),
    claims: dict = Depends(verify_passport_jwt)
):
    """
    Create user info. The user ID is taken from JWT claims.
    """
    # Extract user ID from JWT claims
    user_id = claims.get("sub")
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token: missing user ID"
        )
    
    # Override usid with the one from JWT
    user_info.usid = int(user_id)
    
    # Check if user info already exists
    existing_info = user_info_crud.get_user_info(db, user_info.usid)
    if existing_info:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="User info already exists"
        )
    
    return user_info_crud.create_user_info(db, user_info)


@router.get("/user-info", response_model=UserInfoRead)
def get_user_info(
    db: Session = Depends(get_db),
    claims: dict = Depends(verify_passport_jwt)
):
    """
    Get user info for the authenticated user.
    """
    user_id = claims.get("sub")
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token: missing user ID"
        )
    
    user_info = user_info_crud.get_user_info(db, int(user_id))
    if not user_info:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User info not found"
        )
    
    return user_info


@router.put("/user-info", response_model=UserInfoRead)
def update_user_info(
    user_info_update: UserInfoUpdate,
    db: Session = Depends(get_db),
    claims: dict = Depends(verify_passport_jwt)
):
    """
    Update user info for the authenticated user.
    """
    user_id = claims.get("sub")
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token: missing user ID"
        )
    
    updated_info = user_info_crud.update_user_info(db, int(user_id), user_info_update)
    if not updated_info:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User info not found"
        )
    
    return updated_info


@router.delete("/user-info")
def delete_user_info(
    db: Session = Depends(get_db),
    claims: dict = Depends(verify_passport_jwt)
):
    """
    Delete user info for the authenticated user.
    """
    user_id = claims.get("sub")
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token: missing user ID"
        )
    
    deleted = user_info_crud.delete_user_info(db, int(user_id))
    if not deleted:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User info not found"
        )
    
    return {"message": "User info deleted successfully"}
---
>> core/config.py
from pathlib import Path
from pydantic_settings import BaseSettings, SettingsConfigDict
import os 


BASEDIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
ENV_FILE_PATH = os.path.join(BASEDIR, '.env')
# print(f"Base directory for env file: {BASEDIR}")
# print(f"Full path to env file: {ENV_FILE_PATH}")

class Settings(BaseSettings):
    # These are the variables Pydantic will read from the .env file
    APP_NAME: str = "AI Mentor API"
    REDIS_HOST: str = "localhost"
    REDIS_PORT: int = 6379
    PASSPORT_PUBLIC_KEY: str
    EXPECTED_AUD: str = "1"
    CLOCK_SKEW_LEEWAY: int = 10

    DATABASE_URL: str
    POSTGRES_USER: str
    POSTGRES_PASSWORD: str
    POSTGRES_DB: str
    POSTGRES_SERVER: str
    DATABASE_PORT: int
    
    @property
    def DATABASE_URL(self) -> str:
        url = f"postgresql+psycopg2://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}" \
            f"@{self.POSTGRES_SERVER}:{self.DATABASE_PORT}/{self.POSTGRES_DB}"
        return url


    # This tells Pydantic where to load the .env file from, using the absolute path
    model_config = SettingsConfigDict(env_file=ENV_FILE_PATH, extra='ignore')
    # print(f"model config: {model_config}")
    # print(f"env file path: {ENV_FILE_PATH}")

settings = Settings()
# If PASSPORT_PUBLIC_KEY is actually a file path, load the file
if Path(settings.PASSPORT_PUBLIC_KEY).exists():
    with open(settings.PASSPORT_PUBLIC_KEY, "r", encoding="utf-8") as f:
        settings.PASSPORT_PUBLIC_KEY = f.read()
 ---
>> core/redis.py
import json
import ast
from redis import Redis
from app.core.config import settings

redis_client = Redis(
    host=settings.REDIS_HOST,
    port=settings.REDIS_PORT,
    db=0,
    decode_responses=True,
)

# Legacy functions for backward compatibility
def get_jwt_from_redis(jti: str) -> dict | None:
    """Get JWT payload by JTI (works only if token hasn't expired)"""
    from app.utils.redis_utils import redis_user_manager
    return redis_user_manager.get_jwt_payload(jti)

def get_user_data_by_id(user_id: str) -> dict | None:
    """Get user data directly by user_id (persists longer than JWT)"""
    from app.utils.redis_utils import redis_user_manager
    return redis_user_manager.get_user_data(user_id)

def get_latest_jti_for_user(user_id: str) -> str | None:
    """Get the latest JTI for a user"""
    from app.utils.redis_utils import redis_user_manager
    return redis_user_manager.get_user_latest_jti(user_id)

def store_user_session_data(user_id: str, data: dict, ttl: int = 30 * 24 * 60 * 60):
    """Store additional user session data with extended TTL"""
    from app.utils.redis_utils import redis_user_manager
    return redis_user_manager.store_session_data(user_id, data)
---
>> core/security.py
import time
import jwt
from fastapi import Depends, HTTPException
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jwt import ExpiredSignatureError, InvalidTokenError
from app.core.config import settings
from app.utils.redis_utils import redis_user_manager

auth = HTTPBearer()

def verify_passport_jwt(creds: HTTPAuthorizationCredentials = Depends(auth)):
    token = creds.credentials
    try:
        payload = jwt.decode(
            token,
            settings.PASSPORT_PUBLIC_KEY,
            algorithms=["RS256"],
            audience=settings.EXPECTED_AUD,
            options={"require": ["exp", "iat"]},
            leeway=settings.CLOCK_SKEW_LEEWAY,
        )

        exp = payload["exp"]
        ttl = int(exp - time.time())
        if ttl <= 0:
            raise Exception("Token already expired")

        # Store JWT payload with JTI key (expires with token)
        jti = payload.get("jti")
        if jti:
            redis_user_manager.store_jwt_payload(jti, payload, ttl)
        
        # Store user data with extended TTL (persists beyond JWT expiration)
        user_id = payload.get("sub")
        if user_id:
            redis_user_manager.store_user_data(user_id, payload)

        return payload

    except ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except InvalidTokenError as e:
        raise HTTPException(status_code=401, detail=f"Invalid token: {e}")


def get_user_latest_jti(user_id: str) -> str | None:
    """
    Get the latest JTI for a user, even if their current token is expired.
    This is useful for retrieving user data after token expiration.
    """
    return redis_user_manager.get_user_latest_jti(user_id)


def get_user_data_from_redis(user_id: str) -> dict | None:
    """
    Get user data directly by user_id, without needing JTI.
    This data persists longer than the JWT token itself.
    """
    return redis_user_manager.get_user_data(user_id)

---
>> app/main.py
from fastapi import FastAPI, HTTPException
from app.api.api import api_router
from app.core.redis import redis_client

app = FastAPI(title="AI Mentor API")


@app.on_event("startup")
async def startup_event():
    try:
        redis_client.ping()
        print("✅ Connected to Redis")
    except Exception as e:
        print("❌ Redis connection failed:", e)


@app.get("/")
def read_root():
    """
    A simple root endpoint to confirm the API is running.
    """
    return {"message": "Welcome to the AI Mentor API!"}


# Include all versioned APIs
app.include_router(api_router, prefix="/api/v1")
